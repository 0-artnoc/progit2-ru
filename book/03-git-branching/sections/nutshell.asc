[[_git_branches_overview]]
=== О ветвлении в двух словах

Для четкого понимания механизма ветвлений, необходимо вернуться назад и изучить то, как Git хранит данные.

Как вы можете помнить из <<_getting_started>>, Git не хранит данные в виде последовательности изменений, он использует набор снимков (snapshot).

Когда вы делаете коммит, Git сохраняет его в виде объекта, который содержит указатель на снимок (snapshot) подготовленных данных.
Этот объект так же содержит имя автора и email, сообщение и указатель на коммит или коммиты непосредственно предшествующие данному (его родителей):пустой родитель для первоначального коммита, один родитель для нормального коммита, и множество родителей для результатов слияния веток.

Представьте себе каталог, который содержит дерево файлов,и вы подготавливаете их все вместе, а затем сохраняете в виде одного коммита.
В процессе подготовки вычисляется контрольная сумма кажого файла (SHA-1 как мы узнали из <<_getting_started>>), хранящая версию файла в репозитории Git (Git ссылается на них), затем эти контрольные суммы добавляются в область подготовленных файлов:

[source,console]
----
$ git add README test.rb LICENSE
$ git commit -m 'initial commit of my project'
----

Когда вы создаете коммит командой `git commit`, Git вычисляет контрольные суммы каждого подкаталога (в нашем случае, только основной каталог проекта) и сохраняет эти объекты дерева в репозитории.
Затем Git создает объект коммита с метаданными и указателем на основное дерево проекта для возможности воссоздать этот снимок (snapshot) в случае необходимости.(((git commands, commit)))

Ваш репозиторий Git теперь хранит пять объектов: блоб (blob) для содержимого каждого файла, содиржимое каталога в виде дерева с указателями на блобы сохраненных фалов, сам коммит с указателем на основное дерево, метаданные коммита.

.Коммит и его дерево
image::images/commit-and-tree.png[Коммит и его дерево.]

Если вы сделаете изменения и еще один коммит, тогда следующий коммит сохранит указатель на коммит предшествующий ему.

.Коммит и его родители
image::images/commits-and-parents.png[Коммит и его родители.]

Ветка (branch) в Git - это легко перемещаемый указатель на один из этих коммитов.
Имя основной ветки по умолчанию в Git - `master`.

Когда вы делаете коммиты, то получаете основную ветку, указывающую на ваш последний коммит.
Каждый коммит автоматически двигает этот указатель вперед.

[NOTE]
====
Ветка ``master'' в Git это не специальная ветка.(((master)))
Она тчно такая же как и все остальные ветки.
Она существует почти во всех репозиториях только лишь потому, что ее создает команда `git init`, а большинство людей не меняют ее название.
====

.Ветка и история коммитов
image::images/branch-and-history.png[Ветка и история коммитов.]

[[_create_new_branch]]
==== Создание новой ветки

(((branches, creating)))
Что же на самом деле происходит, когда вы создаете ветку?
Всего лишь создается новый указатель для дальнейшего перемещения.
Допустим вы хотите создать новую ветку с именем ``testing''
Вы можете это сделать командой `git branch` :(((git commands, branch)))

[source,console]
----
$ git branch testing
----

В результате создается новый указатель на тот же самый коммит на котором вы находитесь.

.Две ветки указывают на одну и ту же последоватльность коммитов
image::images/two-branches.png[Две ветки указывают на одну и ту же последоватльность коммитов.]

Как Git определяет на какой ветке вы находитесь?
Он хранит специальный указатель `HEAD`.
Имейте ввиду, что в Git концепция `HEAD` значительно отличается от других систем контроля версий, которые вы могли использовать раньше (Subversion или CVS).
В Git это указатель на локальную ветку, в которой вы находитесь.
В нашем случае мы все еще находимся на ветке ``master''.
Команда `git branch` только _создает_ новую ветку. Переключения не происходит.


.HEAD указывает на ветку
image::images/head-to-master.png[HEAD указывает на ветку.]

Вы можете легко это увидить при помощи простой команды `git log`. Она покажет вам куда указывают указатели веток. Эта опция называется `--decorate`.

[source,console]
----
$ git log --oneline --decorate
f30ab (HEAD, master, testing) add feature #32 - ability to add new
34ac2 fixed bug #1328 - stack overflow under certain conditions
98ca9 initial commit of my project
----

Вы можете видеть ветки ``master'' и ``testing'' которые указывают на коммит `f30ab`.

[[_switching_branches]]
==== Switching Branches

(((branches, switching)))
Для того, чтобы переключиться на существующую ветку выполните команду `git checkout`.(((git commands, checkout)))
Давайте переключимся на ветку ``testing'':

[source,console]
----
$ git checkout testing
----

В результате указатель `HEAD` переместится на ветку `testing`.

.HEAD указывает на текущую ветку
image::images/head-to-testing.png[HEAD указывает на текущую ветку.]

Какой в этом смысл?
Давайте сделаем еще один коммит:

[source,console]
----
$ vim test.rb
$ git commit -a -m 'made a change'
----

.Указатель на ветку HEAD переместился вперед после коммита
image::images/advance-testing.png[Указатель на ветку HEAD переместился вперед после коммита.]

Это интересно, потому что указатель на вашу ветку ``testing'' переместился вперед, а ``master'' все еще указывает на тот коммит, где вы были в момент выполнения команды `git checkout` для переключения веток.
Давайте переключимся назад на ветку ``master'':

[source,console]
----
$ git checkout master
----

.HEAD перемещается когда вы делаете checkout
image::images/checkout-master.png[HEAD перемещается когда вы делаете checkout.]

Эта команда сделала две вещи.
Она переместила указатель`HEAD` назад на ветку ``master'' и вернула файлы в рабочем катологе в то состояние, которое было сохранено в снимке (snapshot) на который указывает ветка.
Это также означает, что все внесенные с этого момента изменения будут относиться к старой версии проекта.
Другими словами откатилась вся работа выполненная в ветке ``testing'' и вы можете продолжать в другом направлении.

[NOTE]
.Переключение веток меняет файлы в рабочем каталоге
====
Важно запомнить, что когда вы перключаете ветки в Git, файлы в рабочем каталоге меняются.
Если вы переключаетесь на старую ветку, то рабочий каталог будет выглядеть так же как выглядел на момент последнего коммита в эту ветку.
Если Git по каким-то причинам не может этого сделать - он не позволит вам переключиться.
====

Давайте сделаем еще несколько изменений и очередной коммит:

[source,console]
----
$ vim test.rb
$ git commit -a -m 'made other changes'
----

Теперь история вашего проекта разделилась (см <<divergent_history>>).
Вы создали ветку, перключились в нее, сделали некоторую работу, а затем вернулись назад в основную ветку и сделали некоторую работу в ней.
Оба изменения изолированны друг от друга: вы можете свободно перключаться туда и обратно, а когда будете готовы - слить их вместе.
И все это вы сделали при помощи простых команд: `branch`, `checkout`и `commit`.

[[divergent_history]]
.Разветвленная история
image::images/advance-master.png[Разветвленная история.]

Вы можете все это увидеть при помощи команды `git log`.
Если вы выполните `git log --oneline --decorate --graph --all`, то получите историю ваших коммитов, положение указателей ваших веток и как разделилась история вашего проекта.

[source,console]
----
$ git log --oneline --decorate --graph --all
* c2b9e (HEAD, master) made other changes
| * 87ab2 (testing) made a change
|/
* f30ab add feature #32 - ability to add new formats to the
* 34ac2 fixed bug #1328 - stack overflow under certain conditions
* 98ca9 initial commit of my project
----

Так как ветка в Git это всего лишь файл, содержащий контрольную сумму (40 символов SHA-1)коммита, на которую указывает ветка, то создание и удаление веток не требует много ресурсов или дискового пространства.
Создание новой ветки - всего лишь запись 41 байта в новый файл (40 символов SHA-1 и символ перевода строки).

В этом заключается принципиальное отличие от большинства старых систем контроля версий, которым требовалось создавать полную копию проекта для выполнения подобной операции.
Это могло занимать несколько секунд или даже минут, в зависимости от размера проекта. В Git это всегда делается мгновенно.
Так же из-за того, что в момент коммита мы сохраняем указатель на предыдущий коммит, очень просто найти общую основу для слияния в автоматическом режиме.
Все это дает возможность разработчикам очень часто создавать и использовать различные ветки.

Давайте посмотрим, почему вам следует делать так же.
