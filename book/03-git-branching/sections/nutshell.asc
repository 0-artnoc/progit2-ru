[[_git_branches_overview]]
=== О ветвлении в двух словах

Для четкого понимания механизма ветвлений, необходимо вернуться назад и изучить то, как Git хранит данные.

Как вы можете помнить из <<_getting_started>>, Git не хранит данные в виде последовательности изменений, он использует набор снимков (snapshot).

Когда вы делаете коммит, Git сохраняет его в виде объекта, который содержит указатель на снимок (snapshot) подготовленных данных.
Этот объект так же содержит имя автора и email, сообщение и указатель на коммит или коммиты непосредственно предшествующие данному (его родителей):пустой родитель для первоначального коммита, один родитель для нормального коммита, и множество родителей для результатов слияния веток.

Представьте себе каталог, который содержит дерево файлов,и вы подготавливаете их все вместе, а затем сохраняете в виде одного коммита.
В процессе подготовки вычисляется контрольная сумма кажого файла (SHA-1 как мы узнали из <<_getting_started>>), хранящая версию файла в репозитории Git (Git ссылается на них), затем эти контрольные суммы добавляются в область подготовленных файлов:

[source,console]
----
$ git add README test.rb LICENSE
$ git commit -m 'initial commit of my project'
----

Когда вы создаете коммит командой `git commit`, Git вычисляет контрольные суммы каждого подкаталога (в нашем случае, только основной каталог проекта) и сохраняет эти объекты дерева в репозитории.
Затем Git создает объект коммита с метаданными и указателем на основное дерево проекта для возможности воссоздать этот снимок (snapshot) в случае необходимости.(((git commands, commit)))

Ваш репозиторий Git теперь хранит пять объектов: блоб (blob) для содержимого каждого файла, содиржимое каталога в виде дерева с указателями на блобы сохраненных фалов, сам коммит с указателем на основное дерево, метаданные коммита.

.Коммит и его дерево
image::images/commit-and-tree.png[Коммит и его дерево.]

Если вы сделаете изменения и еще один коммит, тогда следующий коммит сохранит указатель на коммит предшествующий ему.

.Коммит и его родители
image::images/commits-and-parents.png[Коммит и его родители.]

Ветка (branch) в Git - это легко перемещаемый указатель на один из этих коммитов.
Имя основной ветки по умолчанию в Git - `master`.

Когда вы делаете коммиты, то получаете основную ветку, указывающую на ваш последний коммит.
Каждый коммит автоматически двигает этот указатель вперед.

[NOTE]
====
Ветка ``master'' в Git это не специальная ветка.(((master)))
Она тчно такая же как и все остальные ветки.
Она существует почти во всех репозиториях только лишь потому, что ее создает команда `git init`, а большинство людей не меняют ее название.
====

.Ветка и история коммитов
image::images/branch-and-history.png[Ветка и история коммитов.]

[[_create_new_branch]]
==== Создание новой ветки

(((branches, creating)))
Что же на самом деле происходит, когда вы создаете ветку?
Всего лишь создается новый указатель для дальнейшего перемещения.
Допустим вы хотите создать новую ветку с именем ``testing''
Вы можете это сделать командой `git branch` :(((git commands, branch)))

[source,console]
----
$ git branch testing
----

В результате создается новый указатель на тот же самый коммит на котором вы находитесь.

.Две ветки указывают на одну и ту же последоватльность коммитов
image::images/two-branches.png[Две ветки указывают на одну и ту же последоватльность коммитов.]

Как Git определяет на какой ветке вы находитесь?
Он хранит специальный указатель `HEAD`.
Имейте ввиду, что в Git концепция `HEAD` значительно отличается от других систем контроля версий, которые вы могли использовать раньше (Subversion или CVS).
В Git это указатель на локальную ветку, в которой вы находитесь.
В нашем случае мы все еще находимся на ветке ``master''.
Команда `git branch` только _создает_ новую ветку. Переключения не происходит.


.HEAD указывает на ветку
image::images/head-to-master.png[HEAD указывает на ветку.]

Вы можете легко это увидить при помощи простой команды `git log`. Она покажет вам куда указывают указатели веток. Эта опция называется `--decorate`.

[source,console]
----
$ git log --oneline --decorate
f30ab (HEAD, master, testing) add feature #32 - ability to add new
34ac2 fixed bug #1328 - stack overflow under certain conditions
98ca9 initial commit of my project
----

Вы можете видеть ветки ``master'' и ``testing'' которые указывают на коммит `f30ab`.

[[_switching_branches]]
==== Switching Branches

(((branches, switching)))
Для того, чтобы переключиться на существующую ветку выполните команду `git checkout`.(((git commands, checkout)))
Давайте переключимся на ветку ``testing'':

[source,console]
----
$ git checkout testing
----

В результате указатель `HEAD` переместится на ветку `testing`.

.HEAD указывает на текущую ветку
image::images/head-to-testing.png[HEAD указывает на текущую ветку.]

Какой в этом смысл?
Давайте сделаем еще один коммит:

[source,console]
----
$ vim test.rb
$ git commit -a -m 'made a change'
----

.Указатель на ветку HEAD переместился вперед после коммита
image::images/advance-testing.png[Указатель на ветку HEAD переместился вперед после коммита.]

Это интересно, потому что указатель на вашу ветку ``testing'' переместился вперед, а ``master'' все еще указывает на тот коммит, где вы были в момент выполнения команды `git checkout` для переключения веток.
Давайте переключимся назад на ветку ``master'':

[source,console]
----
$ git checkout master
----

.HEAD перемещается когда вы делаете checkout
image::images/checkout-master.png[HEAD перемещается когда вы делаете checkout.]

Эта команда сделала две вещи.
Она переместила указатель`HEAD` назад на ветку ``master'' и вернула файлы в рабочем катологе в то состояние, которое было сохранено в снимке (snapshot) на который указывает ветка.
Это также означает, что все внесенные с этого момента изменения будут относиться к старой версии проекта.
Другими словами откатилась вся работа выполненная в ветке ``testing'' и вы можете продолжать в другом направлении.

[NOTE]
.Переключение веток меняет файлы в рабочем каталоге
====
Важно запомнить, что когда вы перключаете ветки в Git, файлы в рабочем каталоге меняются.
Если вы переключаетесь на старую ветку, то рабочий каталог будет выглядеть так же как выглядел на момент последнего коммита в эту ветку.
Если Git по каким-то причинам не может этого сделать - он не позволит вам переключиться.
====

Let's make a few changes and commit again:

[source,console]
----
$ vim test.rb
$ git commit -a -m 'made other changes'
----

Now your project history has diverged (see <<divergent_history>>).
You created and switched to a branch, did some work on it, and then switched back to your main branch and did other work.
Both of those changes are isolated in separate branches: you can switch back and forth between the branches and merge them together when you're ready.
And you did all that with simple `branch`, `checkout`, and `commit` commands.

[[divergent_history]]
.Divergent history
image::images/advance-master.png[Divergent history.]

You can also see this easily with the `git log` command.
If you run `git log --oneline --decorate --graph --all` it will print out the history of your commits, showing where your branch pointers are and how your history has diverged.

[source,console]
----
$ git log --oneline --decorate --graph --all
* c2b9e (HEAD, master) made other changes
| * 87ab2 (testing) made a change
|/
* f30ab add feature #32 - ability to add new formats to the
* 34ac2 fixed bug #1328 - stack overflow under certain conditions
* 98ca9 initial commit of my project
----

Because a branch in Git is in actuality a simple file that contains the 40 character SHA-1 checksum of the commit it points to, branches are cheap to create and destroy.
Creating a new branch is as quick and simple as writing 41 bytes to a file (40 characters and a newline).

This is in sharp contrast to the way most older VCS tools branch, which involves copying all of the project's files into a second directory.
This can take several seconds or even minutes, depending on the size of the project, whereas in Git the process is always instantaneous.
Also, because we're recording the parents when we commit, finding a proper merge base for merging is automatically done for us and is generally very easy to do.
These features help encourage developers to create and use branches often.

Let's see why you should do so.
