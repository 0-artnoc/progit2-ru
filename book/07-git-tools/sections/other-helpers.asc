=== Other Helpers

[[_credential_caching]]
==== Credential Helpers

If you don't want to type your username and password on the command line every time you push to an HTTPS Git URL, you can configure Git to pull your credentials from a store of some kind. There are various types of credential helpers available.((credential helpers))

===== Memory Cache

The stored credentials never touch the disk.

	$ git config credential.helper cache

Default is 15 minutes

	$ git config credential.helper 'cache --timeout=300'

Timeout is in seconds, so 300 would be 5 minutes.

	$ git credential-cache exit

Kills the daemon that stores the credentials early.

===== Simple Disk Store

	$ git config credential.helper store

`~/.git-credentials`

The .git-credentials file is stored in plaintext. Each credential is stored on its own line as a URL like:

`https://user:pass@example.com`

===== Windows

msysGit should install wincred helper

msysgit.github.io

	$ git config --global credential.helper wincred


* GitHub for Windows


https://gitcredentialstore.codeplex.com/

[credential]
helper = !\"C:/Program Files (x86)/GitExtensions/GitCredentialWinStore/git-credential-winstore.exe\"


===== Mac Keychain

To use this option, you need to install the `osxkeychain` credential helper and tell Git to use it. If you installed Git using Homebrew, the `osxkeychain` helper may already be installed.

To find out if the `osxkeychain` credential helper is already installed, you can run it directly. If it's installed, you should see something like this:

[source,shell]
----
$ git credential-osxkeychain
usage: git credential-osxkeychain <get|store|erase>
----

If it's not installed, you'll see this:

[source,shell]
----
$ git credential-osxkeychain
# Test for the cred helper
# git: 'credential-osxkeychain' is not a git command. See 'git --help'.
----

If you do not have the `osxkeychain` helper, you can build it yourself out of the `contrib/` directory of Git.

[source,shell]
----
$ cd git/contrib/credential/osxkeychain
$ make
gcc -c -g -O2 -Wall git-credential-osxkeychain.c
gcc -g -O2 -Wall -o git-credential-osxkeychain git-credential-osxkeychain.o -L/opt/boxen/homebrew/lib -Wl,-framework -Wl,Security
----

Now, move the helper into your path somewhere.

[source,shell]
----
sudo mv git-credential-osxkeychain /usr/sbin/
----

Finally, tell Git to use `osxkeychain` using the global `credential.helper` config:

[source,shell]
----
$ git config --global credential.helper osxkeychain
----

You can also delete stored credentials either from the Mac Keychain Access app or via the command line with the `erase` command.

[source,shell]
----
$ git credential-osxkeychain erase
host=github.com
protocol=https
----

===== Gnome Keyring

[source,shell]
----
$ cd /usr/share/git/credential/gnome-keyring
$ make
$ git config --global credential.helper /usr/share/git/credential/gnome-keyring/git-credential-gnome-keyring

$ sudo apt-get install libgnome-keyring-dev
$ cd /usr/share/doc/git/contrib/credential/gnome-keyring
$ sudo make
$ git config --global credential.helper /usr/share/doc/git/contrib/credential/gnome-keyring/git-credential-gnome-keyring
----

===== .netrc

That script would allow you to use gpg-encrypted netrc files, avoiding the issue of having your credentials stored in a plain text file.

-f|--file AUTHFILE
specify netrc-style files.
Files with the .gpg extension will be decrypted by GPG before parsing.
Multiple -f arguments are OK. They are processed in order, and the first matching entry found is returned via the credential helper protocol (see below).

When no -f option is given, .authinfo.gpg, .netrc.gpg, .authinfo, and .netrc files in your home directory are used in this order.

To enable this credential helper:

	$ git config credential.helper 'netrc -f AUTHFILE1 -f AUTHFILE2'

	$ gpg -e -r a_recipient _netrc

You now can delete the _netrc file, keeping only the _netrc.gpg encrypted one

use that encrypted file

	$ git config credential.helper "netrc -f C:/path/to/_netrc.gpg -v"

===== Custom Helper


==== Rerere

The `git rerere` functionality is a bit of a hidden feature.  The name stands for ``reuse recorded resolution'' and as the name implies, it allows you to ask Git to remember how you've resolved a hunk conflict so that the next time it sees the same conflict, Git can automatically resolve it for you.

There are a number of scenarios in which this functionality might be really handy. One of the examples that is mentioned in the documentation is if you want to make sure a long lived topic branch will merge cleanly but don't want to have a bunch of intermediate merge commits. With `rerere` turned on you can merge occasionally, resolve the conflicts, then back out the merge. If you do this continuously, then the final merge should be easy because `rerere` can just do everything for you automatically.

This same tactic can be used if you want to keep a branch rebased so you don't have to deal with the same rebasing conflicts each time you do it.  Or if you want to take a branch that you merged and fixed a bunch of conflicts and then decide to rebase it instead - you likely won't have to do all the same conflicts again.

Another situation is where you merge a bunch of evolving topic branches together into a testable head occasionally, as the Git project itself often does. If the tests fail, you can rewind the merges and re-do them without the topic branch that made the tests fail without having to re-resolve the conflicts again.

To enable the `rerere` functionality, you simply have to run this config setting:

[source,shell]
----
$ git config --global rerere.enabled true
----

You can also turn it on by creating the `.git/rr-cache` directory in a specific repository, but I think the config setting is clearer, and it can be done globally.

Now let's see a simple example. Let's say we have a file that looks like this:

[source,shell]
----
#! /usr/bin/env ruby

def hello
  puts 'hello world'
end
----

In one branch we change the word ``hello'' to ``hola'', then in another branch we change the ``world'' to ``mundo''.

image::../images/rerere1.png[]

When we merge the two branches together, we'll get a merge conflict:

[source,shell]
----
$ git merge i18n-world
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Recorded preimage for 'hello.rb'
Automatic merge failed; fix conflicts and then commit the result.
----

You should notice the new line `Recorded preimage for FILE` in there. Otherwise it should look exactly like a normal merge conflict. At this point, `rerere` can tell us a few things. Normally, you might run `git status` at this point to see what all conflicted:

[source,shell]
----
$ git status
# On branch master
# Unmerged paths:
#   (use "git reset HEAD <file>..." to unstage)
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      hello.rb
#
----

However, `git rerere` will also tell you what it has recorded the pre-merge state for with `git rerere status`:

[source,shell]
----
$ git rerere status
hello.rb
----

And `git rerere diff` will show the current state of the resolution - what you started with to resolve and what you've resolved it to.

[source,shell]
----
$ git rerere diff
--- a/hello.rb
+++ b/hello.rb
@@ -1,11 +1,11 @@
 #! /usr/bin/env ruby

 def hello
-<<<<<<<
-  puts 'hello mundo'
-=======
+<<<<<<< HEAD
   puts 'hola world'
->>>>>>>
+=======
+  puts 'hello mundo'
+>>>>>>> i18n-world
 end
----

Also (and this isn't really related to `rerere`), you can use `ls-files -u` to see the conflicted files and the before, left and right versions:

[source,shell]
----
$ git ls-files -u
100644 39804c942a9c1f2c03dc7c5ebcd7f3e3a6b97519 1	hello.rb
100644 a440db6e8d1fd76ad438a49025a9ad9ce746f581 2	hello.rb
100644 54336ba847c3758ab604876419607e9443848474 3	hello.rb
----

Now you can resolve it to just be `puts 'hola mundo'` and you can run the `rerere diff` command again to see what rerere will remember:

[source,shell]
----
$ git rerere diff
--- a/hello.rb
+++ b/hello.rb
@@ -1,11 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-<<<<<<<
-  puts 'hello mundo'
-=======
-  puts 'hola world'
->>>>>>>
+  puts 'hola mundo'
 end
----

So that basically says, when I see a hunk conflict in a `hello.rb` file that has ``hello mundo'' on one side and ``hola world'' on the other, resolve it to ``hola mundo''.

Now we can mark it as resolved and commit it:

[source,shell]
----
$ git add hello.rb
$ git commit
Recorded resolution for 'hello.rb'.
[master 68e16e5] Merge branch 'i18n'
----

You can see that it "Recorded resolution for FILE".

image::../images/rerere2.png[]

Now, let's undo that merge and then rebase it on top of our master branch instead. We can move our branch back by using `reset` as we saw in <<_reset>>.

[source,shell]
----
$ git reset --hard HEAD^
HEAD is now at ad63f15 i18n the hello
----

Our merge is undone. Now let's rebase the topic branch.

[source,shell]
----
$ git checkout i18n-world
Switched to branch 'i18n-world'

$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: i18n one word
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Failed to merge in the changes.
Patch failed at 0001 i18n one word
----

Now, we got the same merge conflict like we expected, but take a look at the `Resolved FILE using previous resolution` line. If we look at the file, we'll see that it's already been resolved, there are no merge conflict markers in it.

[source,shell]
----
$ cat hello.rb
#! /usr/bin/env ruby

def hello
  puts 'hola mundo'
end
----

Also, `git diff` will show you how it was automatically re-resolved:

[source,shell]
----
$ git diff
diff --cc hello.rb
index a440db6,54336ba..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end
----

image::../images/rerere3.png[]

You can also recreate the conflicted file state with the `checkout` command:

[source,shell]
----
$ git checkout --conflict=merge hello.rb
$ cat hello.rb
#! /usr/bin/env ruby

def hello
<<<<<<< ours
  puts 'hola world'
=======
  puts 'hello mundo'
>>>>>>> theirs
end
----

You can actually have `checkout` do a couple of things in this situation to help you resolve conflicts.  Another interesting value for that option is 'diff3', which will give you left, right and common to help you resolve the conflict manually.

[source,shell]
----
$ git checkout --conflict=diff3 hello.rb
$ cat hello.rb
#! /usr/bin/env ruby

def hello
<<<<<<< ours
  puts 'hola world'
|||||||
  puts 'hello world'
=======
  puts 'hello mundo'
>>>>>>> theirs
end
----

You can actually do that any time you have a merge conflict to get more context. For now though, you can re-resolve it by just running `rerere` again:

[source,shell]
----
$ git rerere
Resolved 'hello.rb' using previous resolution.
$ cat hello.rb
#! /usr/bin/env ruby

def hello
  puts 'hola mundo'
end
----

We have re-resolved the file automatically using the `rerere` cached resolution. You can now add and continue the rebase to complete it.

[source,shell]
----
$ git add hello.rb
$ git rebase --continue
Applying: i18n one word
----

So, if you do a lot of re-merges, or want to keep a topic branch up to date with your master branch without a ton of merges, or you rebase often, you can turn on `rerere` to help your life out a bit.
